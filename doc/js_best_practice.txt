===========
js 最佳实践
===========

如何封装业务逻辑。

.. contents::

对象/命名空间
=============

对于js来说，对象也可当作是命名空间。

最直接的做法::

  var status = 1;
  function change_status(){
      if(status==1)
          status = 2;
      else
          status = 1;
  }

  change_status();

使用对象进行封装 ::

  var status = {
      _status : 1,
      change : function(){
          if(this._status==1)
              this._status = 2;
          else
              this._status = 1;
      }
  }

  status.change();

利用闭包使用私有成员 ::

  var status = (function(){
      var private_status = 1;
      return {
          change:function(){
              if(private_status==1)
                  private_status = 2;
              else
                  private_status = 1;
          }
      }
  })()
  status.change();

上面的 status 对象都是单件，也可进一步独立出 class，创建多个实例 ::

  var Status = function(init_status){
      var private_status = init_status;
      return {
          change:function(){
              if(private_status==1)
                  private_status = 2;
              else
                  private_status = 1;
          }
      }
  }
  var status1 = Status(1);
  status1.change();
  var status2 = Status(2);
  status2.change();

最后还可以对比下 js 本身的基于 prototype 的对象模型 ::

  var Status = function(init_status){
      this._status = init_status;
  }
  Status.prototype.change(){
      if(this._status==1)
          this._status=2
      else
          this._status=1
  }
  var status1 = Status(1);
  status1.change();
  var status2 = Status(2);
  status2.change();

以上各个方法除了第一种不建议使用外，其他三种方式都有其应用范围。
第二种对于封装业务逻辑来说最为实用，代码很直观自然，阅读调试都很方便。
后面两种方式通过闭包实现了私有成员，但增加了抽象程度，也就增加了阅读，理解和调试的难度。
甚至在性能上也要差一点点。
最后一种方式等于是模拟了一些语言的 class 的效果，可以重复创建实例。

装饰器
======

function logger(func)
{
    return function(){
        log('enter'+func.name);
        func.apply(this, arguments);
        log('exit'+func.name);
    }
}
function test()
{
... do some thing
}
test = logger(test)


function bind(func, obj)
{
    return function(){
        func.apply(obj, arguments);
    }
}

function test(){alert(this.a);}
test = bind(test, {'a':2});


3、chain
js 接口模式
 
分离异步数据读取与回调，并采用chain组合多个回调。
 
装饰模式

周末对js模式做仔细思考


